C51 COMPILER V9.60.0.0   TEMPCONTROL                                                       11/16/2024 15:17:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TEMPCONTROL
OBJECT MODULE PLACED IN .\Objects\TempControl.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Logic\TempControl.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include;.\Std
                    -Driver\inc;.\Hardware) DEBUG PRINT(.\Listings\TempControl.lst) TABS(2) OBJECT(.\Objects\TempControl.obj)

line level    source

   1          #include "ADCCfg.h"
   2          #include "LEDMgmt.h"
   3          #include "delay.h"
   4          #include "ModeControl.h"
   5          #include "OutputChannel.h"
   6          #include "cms8s6990.h"
   7          #include "PWMCfg.h"
   8          
   9          //PI»·²ÎÊýºÍ×îÐ¡µçÁ÷ÏÞÖÆ
  10          #define ProtFullScale 18000 //PI»·Êä³öµÄÏ¸·ÖÖµ
  11          #define IntegrateFullScale 12000 //»ý·ÖµÄFull Scale
  12          #define IntegralFactor 150 //»ý·ÖÏµÊý(Ô½´óÊ±¼ä³£ÊýÔ½¸ß)
  13          #define MinumumILED 900 //½µµµÏµÍ³ËùÄÜ´ïµ½µÄ×îµÍµçÁ÷(mA)
  14          
  15          //ÎÂ¶ÈÅäÖÃ
  16          #define ForceOffTemp 75 //¹ýÈÈ¹Ø»úÎÂ¶È
  17          #define ForceDisableTurboTemp 60 //³¬¹ý´ËÎÂ¶ÈÎÞ·¨½øÈë¼«ÁÁ
  18          #define ConstantTemperature 53 //ÎÂ¿ØÆô¶¯ºóÎ¬³ÖµÄÎÂ¶È
  19          
  20          //ÎÂ¶È¿ØÖÆÓÃÈ«¾Ö±äÁ¿
  21          static int TempIntegral=0;
  22          static int TempProtBuf=0;
  23          bit IsTempLIMActive=0;  //ÎÂ¿ØÊÇ·ñÒÑ¾­Æô¶¯
  24          bit IsDisableTurbo=0;  //½ûÖ¹ÔÙ¶È½øÈëµ½¼«ÁÁµµ
  25          bit IsForceLeaveTurbo=0; //ÊÇ·ñÇ¿ÖÆÀë¿ª¼«ÁÁµµ
  26          
  27          //ÉÏµçÊ±¼ì²âNTC×´Ì¬
  28          void CheckNTCStatus(void)
  29            {
  30   1        char i=64;
  31   1        //¼ì²éÎÂ¶ÈÊý¾Ý
  32   1        do
  33   1          {
  34   2          delay_ms(10);
  35   2          SystemTelemHandler();
  36   2          if(Data.IsNTCOK)break; //NTCÒÑ¾­Õý³£¹¤×÷£¬ÍË³ö¼ì²â
  37   2          i--;
  38   2          }   
  39   1        while(i);
  40   1        if(!i) //¾­¹ý0.64ÃëµÄµÈ´ýÈÔÈ»²»´ï±ê£¬±¨´í
  41   1          {
  42   2          LEDMode=LED_Amber; 
  43   2          LEDControlHandler(); //NTC×Ô¼ì²»Í¨¹ý£¬»ÆµÆ³£ÁÁ
  44   2          while(1); //ËÀÑ­»·
  45   2          }
  46   1        }
  47          
  48          //Êä³öÏÞÁ÷ÖµµÄ°Ù·Ö±È
  49          int ThermalILIMCalc(int Input)
  50            {
  51   1        float buf,ILED,itgbuf;
  52   1        //ÎÂ¿Ø±»½ûÖ¹»òÕß´«ÈëµÄµçÁ÷Ð¡ÓÚµÈÓÚ0£¬´«Èë¶àÉÙµçÁ÷¾Í·µ»Ø¶àÉÙ 
  53   1        if(!IsTempLIMActive||Input<=0)return Input;
  54   1        //¸½¼Ó±ÈÀýÏî
C51 COMPILER V9.60.0.0   TEMPCONTROL                                                       11/16/2024 15:17:14 PAGE 2   

  55   1        buf=(float)TempProtBuf/(float)ProtFullScale; //»»³É±ÈÀýÏî
  56   1        buf*=100;
  57   1        //¸½¼Ó»ý·ÖÏî
  58   1        itgbuf=(float)TempIntegral/(float)IntegrateFullScale; //»»Ëã»ý·ÖÏî
  59   1        buf+=itgbuf*10;//½«»»ËãÍê±ÏµÄ»ý·ÖÏî¼ÓÈëµ½±ÈÀýÏîÖÐ£¨×î¶àÔì³É10%µÄ¹¦ÂÊ²¨¶¯£©
  60   1        if(buf<0)buf=0;
  61   1        if(buf>100)buf=100; //ÏÞ·ù
  62   1        //½«ÊäÈëµçÁ÷ºÍ´«ÈëµÄµçÁ÷Öµ½øÐÐ¼ÆËã  
  63   1        if(Input<MinumumILED)return MinumumILED; //ÊäÈë×î´óµçÁ÷²ÎÊýÐ¡ÓÚÔÊÐíµÄÏ¸·ÖÖµ
  64   1        ILED=(float)Input-(float)MinumumILED; //¼ÆËãÊäÈëµçÁ÷Ö®¼äµÄ²îÖµ
  65   1        ILED/=(float)100; //Ëã³öÏ¸·ÖÖµ
  66   1        ILED*=(float)100-buf; //Ëã³öÔÚ×îµÍµçÁ÷Öµµ½´ïÄ¿±êµçÁ÷ÖµÖ®¼äµÄÔöÁ¿¦¤
  67   1        ILED+=(float)MinumumILED; //¼ÓÉÏ×îÐ¡µçÁ÷µÃµ½Ä¿±êÖµ
  68   1        return (int)ILED; //·µ»ØÊµ¼ÊµÄµçÁ÷Öµ
  69   1        }
  70            
  71          //ÎÂ¿Ø¼ÆËãº¯Êý
  72          void ThermalCalcProcess(void)
  73            {
  74   1        int Err;
  75   1        //ÎÂ¶È´«¸ÐÆ÷´íÎó
  76   1        if(!Data.IsNTCOK)
  77   1          {
  78   2          ReportError(Fault_NTCFailed);
  79   2          return;
  80   2          }
  81   1        //µ±Í²Í·ÎÂ¶È¹ý¸ßÊ±£¬¹Ø±Õ¼«ÁÁµµ  
  82   1        if(Data.Systemp>(ForceOffTemp-10))IsForceLeaveTurbo=1;  //ÎÂ¶È¾àÀë¹Ø»ú±£»¤µÄ¼ä¾à²»µ½10¶È£¬Á¢¼´ÍË³ö¼«ÁÁ
  83   1        if(Data.Systemp>ForceDisableTurboTemp)IsDisableTurbo=1;
  84   1        else if(Data.Systemp<(ForceDisableTurboTemp-10))IsDisableTurbo=0;
  85   1        if(IsForceLeaveTurbo&&!IsDisableTurbo)IsForceLeaveTurbo=0;   //Èç¹ûÇ¿ÖÆÍË³ö¼«ÁÁ±êÖ¾Î»ÖÃÎ»ÇÒÎÂ¶ÈÒÑ¾­»ØÂäµ½¼
             -«ÁÁ½âËøµÄãÐÖµµã£¬Ôò¸´Î»
  86   1        //¹ýÈÈ¹ÊÕÏ
  87   1        if(Data.Systemp>ForceOffTemp)
  88   1          {
  89   2          ReportError(Fault_OverHeat);
  90   2          return;
  91   2          }
  92   1        else if(Data.Systemp<(ForceOffTemp-20)&&ErrCode==Fault_OverHeat)
  93   1          {
  94   2          ErrCode=Fault_None;
  95   2          SwitchToGear(Mode_OFF); //ÎÂ¶È»ØÂä£¬Ïû³ý¹ÊÕÏÖ¸Ê¾
  96   2          }
  97   1        //PI»·Ê¹ÄÜ¿ØÖÆ
  98   1        if(!CurrentMode->IsNeedStepDown)IsTempLIMActive=0; //µ±Ç°µ²Î»²»ÐèÒª½µµµ
  99   1        else if(Data.Systemp>ConstantTemperature)IsTempLIMActive=1;
 100   1        else if(Data.Systemp<(ConstantTemperature-10))IsTempLIMActive=0; //ÖÍ»Ø¿ØÖÆ
 101   1        //PI»·¹Ø±Õ£¬¸´Î»ÊýÖµ
 102   1        if(!IsTempLIMActive)
 103   1          {
 104   2          TempIntegral=0;
 105   2          TempProtBuf=0;
 106   2          }
 107   1        //½øÐÐPI¼ÆËã(½öÔÚÊä³ö¿ªÆôµÄÊ±ºò½øÐÐ)
 108   1        else if(Current>0)
 109   1          {
 110   2          //ÇóÎó²î
 111   2          Err=Data.Systemp-ConstantTemperature;
 112   2          //±ÈÀýÏî(P)
 113   2          TempProtBuf+=(iabsf(Err)>1)?Err*(iabsf(Current/6000)+1):0; //¶¯Ì¬±ÈÀýÏîµ÷Õû¹¦ÄÜ
 114   2          if(TempProtBuf>ProtFullScale)TempProtBuf=ProtFullScale;
 115   2          if(TempProtBuf<0)TempProtBuf=0;  //ÏÞÖÆ·ù¶È
C51 COMPILER V9.60.0.0   TEMPCONTROL                                                       11/16/2024 15:17:14 PAGE 3   

 116   2          //»ý·ÖÏî(I)
 117   2          TempIntegral+=Err; //ÀÛ¼ÓÎó²î
 118   2          if(TempIntegral>IntegrateFullScale)TempIntegral=IntegrateFullScale;
 119   2          if(TempIntegral<-IntegrateFullScale)TempIntegral=-IntegrateFullScale;  //»ý·ÖÏÞ·ù
 120   2          }
 121   1        } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    757    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
