C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/15/2024 17:30:59 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SIDEKEY
OBJECT MODULE PLACED IN .\Objects\SideKey.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\SideKey.c OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include;.\StdDriver
                    -\inc;.\Hardware) DEBUG OBJECTEXTEND PRINT(.\Listings\SideKey.lst) TABS(2) OBJECT(.\Objects\SideKey.obj)

line level    source

   1          #include "delay.h"
   2          #include "SideKey.h"
   3          #include "GPIO.h"
   4          #include "cms8s6990.h"
   5          #include "PinDefs.h"
   6          #include "ModeControl.h"
   7          
   8          //å…¨å±€å˜é‡
   9          sbit KeyPress=SideKeyGPIOP^SideKeyGPIOx; //ä¾§æŒ‰æŒ‰é”®è¾“å…¥
  10          static bit IsKeyPressed = 0; //æŒ‰é”®æ˜¯å¦æŒ‰ä¸‹
  11          static unsigned char KeyTimer[2];//è®¡æ—¶å™¨0ç”¨äºæŒ‰é”®æŒ‰ä¸‹è®¡æ—¶ï¼Œè®¡æ—¶å™¨1ç”¨äºè¿æŒ‰æ£€æµ‹è®¡æ—¶
  12          static KeyEventStrDef Keyevent; //æŒ‰é”®äº‹ä»¶
  13          volatile int SleepTimer;
  14          
  15          //å†…éƒ¨æŒ‰é”®æ£€æµ‹ç”¨çš„å˜é‡
  16          xdata unsigned char KeyState;
  17          
  18          //åˆå§‹åŒ–ä¾§æŒ‰é”®
  19          void SideKeyInit(void)
  20            {
  21   1        GPIOCfgDef KeyInitCfg;
  22   1        //è®¾ç½®ç»“æ„ä½“
  23   1        KeyInitCfg.Mode=GPIO_IPU;
  24   1        KeyInitCfg.Slew=GPIO_Slow_Slew;   
  25   1        KeyInitCfg.DRVCurrent=GPIO_Low_Current; //é…ç½®ä¸ºä¸Šæ‹‰è¾“å…¥
  26   1        //æŒ‰é”®è¾“å…¥åˆå§‹åŒ–
  27   1        GPIO_SetMUXMode(SideKeyGPIOG,SideKeyGPIOx,GPIO_AF_GPIO); //é…ç½®ä¸ºGPIO      
  28   1        GPIO_ConfigGPIOMode(SideKeyGPIOG,GPIOMask(SideKeyGPIOx),&KeyInitCfg);//æŒ‰é”®è¾“å…¥
  29   1        GPIO_EnableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ä½¿èƒ½ä¸­æ–­åŠŸèƒ½
  30   1        GPIO_SetExtIntMode(SideKeyGPIOG,SideKeyGPIOx,GPIO_Int_Falling);//è®¾ç½®ä¸ºä¸‹é™æ²¿è§¦å‘
  31   1        //åˆå§‹åŒ–ç»“æ„ä½“å†…å®¹å’Œå®šæ—¶å™¨
  32   1        SleepTimer=SleepTimeOut*8;//å¤ä½å®šæ—¶å™¨
  33   1        KeyState=0xFF;
  34   1        KeyTimer[0]=0x00;
  35   1        KeyTimer[1]=0x00;
  36   1        Keyevent.LongPressEvent=0;
  37   1        Keyevent.ShortPressCount=0;
  38   1        Keyevent.ShortPressEvent=0;
  39   1        Keyevent.PressAndHoldEvent=0;
  40   1        }
  41            
  42          //æ£€æµ‹æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿ
  43          bit IsKeyEventOccurred(void)
  44            {
  45   1        if(Keyevent.LongPressEvent)return 1;
  46   1        if(Keyevent.ShortPressEvent)return 1;
  47   1        if(Keyevent.PressAndHoldEvent)return 1;
  48   1        //ä»€ä¹ˆä¹Ÿæ²¡æœ‰ï¼Œé€€å‡ºä¸å¤„ç†
  49   1        return 0; 
  50   1        } 
  51          
  52          //ä¾§æŒ‰æŒ‰é”®è®¡æ—¶æ¨¡å—
  53          void SideKey_TIM_Callback(void)
  54            {
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/15/2024 17:30:59 PAGE 2   

  55   1        unsigned char buf;
  56   1        //å®šæ—¶å™¨0ï¼ˆç”¨äºæŒ‰é”®çŸ­æŒ‰å’Œé•¿æŒ‰è®¡æ—¶ï¼‰
  57   1        if(KeyTimer[0]&0x80)
  58   1          {
  59   2          buf=KeyTimer[0]&0x7F;
  60   2          if(buf<(unsigned char)LongPressTime)buf++;
  61   2          KeyTimer[0]&=0x80;
  62   2          KeyTimer[0]|=buf; //å°†æ•°å€¼å–å‡ºæ¥ï¼ŒåŠ 1å†å†™å›å»
  63   2          }
  64   1        else KeyTimer[0]=0; //å®šæ—¶å™¨å…³é—­
  65   1        //å®šæ—¶å™¨1ï¼ˆç”¨äºæŒ‰é”®è¿æŒ‰æ£€æµ‹ï¼‰
  66   1        if(KeyTimer[1]&0x80)
  67   1          {
  68   2          buf=KeyTimer[1]&0x7F;
  69   2          if(buf<(unsigned char)ContShortPressWindow)buf++;
  70   2          KeyTimer[1]&=0x80;
  71   2          KeyTimer[1]|=buf; //å°†æ•°å€¼å–å‡ºæ¥ï¼ŒåŠ 1å†å†™å›å»
  72   2          }
  73   1        else KeyTimer[1]=0; //å®šæ—¶å™¨å…³é—­
  74   1        }
  75          
  76          //ä¾§æŒ‰GPIOä¸­æ–­å›è°ƒå¤„ç†
  77          void SideKey_Int_Callback(void)
  78            {
  79   1        unsigned char time;
  80   1        //å¼€å§‹å“åº”
  81   1        if(GPIO_GetExtIntMode(SideKeyGPIOG,SideKeyGPIOx)==GPIO_Int_Rising)
  82   1          {
  83   2          IsKeyPressed = 0;
  84   2          time=KeyTimer[0]&0x7F;//ä»è®¡æ—¶å™¨å–å‡ºæŒ‰é”®æŒ‰ä¸‹æ—¶é—´
  85   2          KeyTimer[0]=0;//å¤ä½å¹¶å…³é—­å®šæ—¶å™¨0
  86   2          if(Keyevent.LongPressDetected||Keyevent.PressAndHoldEvent)//å¦‚æœå·²ç»æ£€æµ‹åˆ°é•¿æŒ‰äº‹ä»¶åˆ™ä¸‹é¢ä»
             -€ä¹ˆéƒ½ä¸åš
  87   2            {
  88   3            Keyevent.PressAndHoldEvent=0;
  89   3            Keyevent.LongPressDetected=0;//æ¸…é™¤æ£€æµ‹åˆ°çš„è¡¨ç¤º
  90   3            }
  91   2          else if(time<(unsigned char)LongPressTime)//çŸ­æŒ‰äº‹ä»¶å‘ç”Ÿ      
  92   2            {
  93   3            if(Keyevent.ShortPressCount<10)Keyevent.ShortPressCount++;//ç´¯åŠ æœ‰æ•ˆçš„çŸ­æŒ‰æ¬¡æ•°
  94   3            KeyTimer[1]=0x80;//å¯åŠ¨çŸ­æŒ‰å®Œæ¯•ç­‰å¾…ç»Ÿè®¡çš„è®¡æ—¶å™¨
  95   3            }     
  96   2          }
  97   1        //æŒ‰é”®æŒ‰ä¸‹
  98   1        else
  99   1          {
 100   2          IsKeyPressed = 1;//æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 101   2          SleepTimer=8*SleepTimeOut; //ç¡çœ æ—¶é—´å»¶é•¿
 102   2          if(KeyTimer[1]&0x80)KeyTimer[1]=0x80;//å¤ä½
 103   2          if(!(KeyTimer[0]&0x80))KeyTimer[0]=0x80;//å¯åŠ¨è®¡æ—¶
 104   2          }
 105   1        //ç¦æ­¢INT0ä¸­æ–­
 106   1        GPIO_DisableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ç¦æ­¢ä¸­æ–­åŠŸèƒ½
 107   1        KeyState=0x0A; //å¤ä½æ£€æµ‹æ¨¡å—
 108   1        }
 109          
 110          //æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 111          void MarkAsKeyPressed(void)
 112            {
 113   1        //ç¦æ­¢INT0ä¸­æ–­
 114   1        GPIO_DisableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ç¦æ­¢ä¸­æ–­åŠŸèƒ½
 115   1        KeyState=0xAA; //å¤ä½æ£€æµ‹æ¨¡å—
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/15/2024 17:30:59 PAGE 3   

 116   1        //æ ‡è®°æŒ‰é”®å·²è¢«æŒ‰ä¸‹
 117   1        IsKeyPressed = 1;//æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 118   1        if(KeyTimer[1]&0x80)KeyTimer[1]=0x80;//å¤ä½
 119   1        if(!(KeyTimer[0]&0x80))KeyTimer[0]=0x80;//å¯åŠ¨è®¡æ—¶
 120   1        }   
 121            
 122          //åœ¨å•å‡»åŒå‡»ä¸‰å‡»+é•¿æŒ‰è§¦å‘çš„æ—¶å€™æ¸…é™¤å•å‡»äº‹ä»¶çš„è®°å½•
 123          static void ClickAndHoldEventHandler(int PressCount)
 124            {
 125   1        KeyTimer[1]=0; //å…³é—­åéƒ¨æ£€æµ‹å®šæ—¶å™¨
 126   1        Keyevent.ShortPressEvent=0;
 127   1        Keyevent.ShortPressCount=0; //çŸ­æŒ‰æ¬¡æ•°ä¸º0
 128   1        Keyevent.LongPressDetected=0;
 129   1        Keyevent.LongPressEvent=0;//çŸ­æŒ‰å’Œé•¿æŒ‰äº‹ä»¶æ²¡å‘ç”Ÿ
 130   1        //å•å‡»+é•¿æŒ‰
 131   1        Keyevent.PressAndHoldEvent=(PressCount==1)?1:0;
 132   1        }
 133          //ä¾§æŒ‰é”®é€»è¾‘å¤„ç†å‡½æ•°
 134          void SideKey_LogicHandler(void)
 135            {   
 136   1        unsigned char buf;
 137   1        //å¯¹æŒ‰é”®è¿›è¡Œå»æŠ–ä»¥åŠé‡æ–°æ‰“å¼€ä¸­æ–­çš„åˆ¤æ–­
 138   1        if(!GPIO_CheckIfIntEnabled(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)))
 139   1          {
 140   2          KeyState<<=1;
 141   2          if(KeyPress)KeyState|=0x01;
 142   2          else KeyState&=0xFE;  //é™„åŠ ç»“æœ
 143   2          //é‡æ–°æ‰“å¼€ä¸­æ–­
 144   2          buf=KeyState&0x0F;
 145   2          if(buf==0x0F||KeyState==0x00)
 146   2            {
 147   3            P0EXTIF=0;//æ¸…é™¤GPIO Flag
 148   3            IsKeyPressed=buf==0x0F?0:1; //æ›´æ–°æŒ‰é”®çŠ¶æ€  
 149   3            GPIO_SetExtIntMode(SideKeyGPIOG,SideKeyGPIOx,buf==0x0F?GPIO_Int_Falling:GPIO_Int_Rising);//å¦‚æœå½“å‰
             -æŒ‰é”®æ˜¯æ¾å¼€çŠ¶æ€åˆ™è®¾ç½®ä¸ºä¸‹é™æ²¿ï¼Œå¦åˆ™è®¾ç½®ä¸ºä¸Šå‡æ²¿
 150   3            GPIO_EnableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ä½¿èƒ½ä¸­æ–­åŠŸèƒ½
 151   3            }
 152   2          } 
 153   1        //å¦‚æœæŒ‰é”®é‡Šæ”¾ç­‰å¾…è®¡æ—¶å™¨åœ¨è®¡æ—¶çš„è¯ï¼Œåˆ™é‡ç½®å®šæ—¶å™¨
 154   1        if(IsKeyPressed&&(KeyTimer[1]&0x80))KeyTimer[1]=0x80;
 155   1        //é•¿æŒ‰3ç§’çš„æ—¶é—´åˆ°
 156   1        if(IsKeyPressed&&KeyTimer[0]==0x80+(unsigned char)LongPressTime)
 157   1          {
 158   2          //å¤„ç†å¤šå‡»+é•¿æŒ‰äº‹ä»¶
 159   2          if(Keyevent.ShortPressCount>0)ClickAndHoldEventHandler(Keyevent.ShortPressCount);
 160   2          else //é•¿æŒ‰äº‹ä»¶
 161   2            {
 162   3            Keyevent.ShortPressCount=0;
 163   3            Keyevent.PressAndHoldEvent=0;
 164   3            Keyevent.LongPressEvent=1;//é•¿æŒ‰äº‹ä»¶å‘ç”Ÿ
 165   3            Keyevent.LongPressDetected=1;//é•¿æŒ‰æ£€æµ‹åˆ°äº†  
 166   3            }
 167   2          KeyTimer[0]=0;//å…³é—­å®šæ—¶å™¨
 168   2          }
 169   1        //è¿ç»­çŸ­æŒ‰åºåˆ—å·²ç»ç»“æŸ
 170   1        if(!IsKeyPressed&&KeyTimer[1]==0x80+(unsigned char)ContShortPressWindow)
 171   1          {
 172   2          KeyTimer[1]=0;//å…³é—­å®šæ—¶å™¨1
 173   2          if(!Keyevent.LongPressDetected) 
 174   2            Keyevent.ShortPressEvent=1;//å¦‚æœé•¿æŒ‰äº‹ä»¶å·²ç»ç”Ÿæ•ˆï¼Œåˆ™æ¾å¼€å¼€å…³æ—¶çŸ­æŒ‰äº‹ä»¶ä¸ç”Ÿæ•ˆ
 175   2          else 
 176   2            Keyevent.LongPressDetected=0; //æ¸…é™¤é•¿æŒ‰æ£€æµ‹åˆ°çš„ç»“æœ
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/15/2024 17:30:59 PAGE 4   

 177   2          }
 178   1        }
 179          //è·å–ä¾§æŒ‰é”®ç‚¹æŒ‰æ¬¡æ•°çš„è·å–å‡½æ•°
 180          int getSideKeyShortPressCount(bit IsRemoveResult)
 181            {
 182   1        short buf;
 183   1        if(Keyevent.LongPressDetected||Keyevent.PressAndHoldEvent)return 0;
 184   1        if(!Keyevent.ShortPressEvent)return 0;
 185   1        buf=Keyevent.ShortPressCount;
 186   1        if(IsRemoveResult)
 187   1          {
 188   2          Keyevent.ShortPressEvent=0; //è·å–äº†çŸ­æŒ‰ç»“æœä¹‹åå¤ä½
 189   2          Keyevent.ShortPressCount=0;  //è·å–äº†çŸ­æŒ‰è¿å‡»æ¬¡æ•°åæ¸…é›¶ç»“æœ
 190   2          }
 191   1        return buf;   
 192   1        }
 193          //è·å–ä¾§æŒ‰æŒ‰é”®é•¿æŒ‰2ç§’äº‹ä»¶çš„å‡½æ•°
 194          bit getSideKeyLongPressEvent(void)
 195            {
 196   1        if(!Keyevent.LongPressEvent)return 0;
 197   1        else Keyevent.LongPressEvent=0;
 198   1        return 1;
 199   1        }
 200          //è·å–ä¾§æŒ‰æŒ‰é”®ä¸€ç›´æŒ‰ä¸‹çš„å‡½æ•°
 201          bit getSideKeyHoldEvent(void)
 202            {
 203   1        return Keyevent.LongPressDetected?1:0;
 204   1        }
 205          //è·å–ä¾§æŒ‰æŒ‰é”®çŸ­æŒ‰ä¸€ä¸‹ç«‹åˆ»é•¿æŒ‰çš„å‡½æ•°
 206          bit getSideKeyClickAndHoldEvent(void)
 207            {
 208   1          return Keyevent.PressAndHoldEvent?1:0;
 209   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    536    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
