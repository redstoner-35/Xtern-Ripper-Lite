C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/16/2024 15:17:13 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SIDEKEY
OBJECT MODULE PLACED IN .\Objects\SideKey.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Hardware\SideKey.c OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include;.\StdD
                    -river\inc;.\Hardware) DEBUG PRINT(.\Listings\SideKey.lst) TABS(2) OBJECT(.\Objects\SideKey.obj)

line level    source

   1          #include "delay.h"
   2          #include "SideKey.h"
   3          #include "GPIO.h"
   4          #include "cms8s6990.h"
   5          #include "PinDefs.h"
   6          #include "ModeControl.h"
   7          
   8          //å…¨å±€å˜é‡
   9          sbit KeyPress=SideKeyGPIOP^SideKeyGPIOx; //ä¾§æŒ‰æŒ‰é”®è¾“å…¥
  10          static bit IsKeyPressed = 0; //æŒ‰é”®æ˜¯å¦æŒ‰ä¸‹
  11          static unsigned char KeyTimer[2];//è®¡æ—¶å™¨0ç”¨äºæŒ‰é”®æŒ‰ä¸‹è®¡æ—¶ï¼Œè®¡æ—¶å™¨1ç”¨äºè¿æŒ‰æ£€æµ‹è®¡æ—¶
  12          static KeyEventStrDef Keyevent; //æŒ‰é”®äº‹ä»¶
  13          volatile int SleepTimer;
  14          
  15          //å†…éƒ¨æŒ‰é”®æ£€æµ‹ç”¨çš„å˜é‡
  16          xdata unsigned char KeyState;
  17          
  18          //åˆå§‹åŒ–ä¾§æŒ‰é”®
  19          void SideKeyInit(void)
  20            {
  21   1        GPIOCfgDef KeyInitCfg;
  22   1        //è®¾ç½®ç»“æ„ä½“
  23   1        KeyInitCfg.Mode=GPIO_IPU;
  24   1        KeyInitCfg.Slew=GPIO_Slow_Slew;   
  25   1        KeyInitCfg.DRVCurrent=GPIO_Low_Current; //é…ç½®ä¸ºä¸Šæ‹‰è¾“å…¥
  26   1        //æŒ‰é”®è¾“å…¥åˆå§‹åŒ–
  27   1        GPIO_SetMUXMode(SideKeyGPIOG,SideKeyGPIOx,GPIO_AF_GPIO); //é…ç½®ä¸ºGPIO      
  28   1        GPIO_ConfigGPIOMode(SideKeyGPIOG,GPIOMask(SideKeyGPIOx),&KeyInitCfg);//æŒ‰é”®è¾“å…¥
  29   1        GPIO_EnableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ä½¿èƒ½ä¸­æ–­åŠŸèƒ½
  30   1        GPIO_SetExtIntMode(SideKeyGPIOG,SideKeyGPIOx,GPIO_Int_Falling);//è®¾ç½®ä¸ºä¸‹é™æ²¿è§¦å‘
  31   1        EIP1|=0x04; //å°†æŒ‰é”®ä¸­æ–­è®¾ç½®ä¸ºé«˜ä¼˜å…ˆçº§
  32   1        //åˆå§‹åŒ–ç»“æ„ä½“å†…å®¹å’Œå®šæ—¶å™¨
  33   1        SleepTimer=SleepTimeOut*8;//å¤ä½å®šæ—¶å™¨
  34   1        KeyState=0xFF;
  35   1        KeyTimer[0]=0x00;
  36   1        KeyTimer[1]=0x00;
  37   1        Keyevent.LongPressEvent=0;
  38   1        Keyevent.ShortPressCount=0;
  39   1        Keyevent.ShortPressEvent=0;
  40   1        Keyevent.PressAndHoldEvent=0;
  41   1        }
  42            
  43          //æ£€æµ‹æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿ
  44          bit IsKeyEventOccurred(void)
  45            {
  46   1        if(Keyevent.LongPressEvent)return 1;
  47   1        if(Keyevent.ShortPressEvent)return 1;
  48   1        if(Keyevent.PressAndHoldEvent)return 1;
  49   1        //ä»€ä¹ˆä¹Ÿæ²¡æœ‰ï¼Œé€€å‡ºä¸å¤„ç†
  50   1        return 0; 
  51   1        } 
  52          
  53          //ä¾§æŒ‰æŒ‰é”®è®¡æ—¶æ¨¡å—
  54          void SideKey_TIM_Callback(void)
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/16/2024 15:17:13 PAGE 2   

  55            {
  56   1        unsigned char buf;
  57   1        //å®šæ—¶å™¨0ï¼ˆç”¨äºæŒ‰é”®çŸ­æŒ‰å’Œé•¿æŒ‰è®¡æ—¶ï¼‰
  58   1        if(KeyTimer[0]&0x80)
  59   1          {
  60   2          buf=KeyTimer[0]&0x7F;
  61   2          if(buf<(unsigned char)LongPressTime)buf++;
  62   2          KeyTimer[0]&=0x80;
  63   2          KeyTimer[0]|=buf; //å°†æ•°å€¼å–å‡ºæ¥ï¼ŒåŠ 1å†å†™å›å»
  64   2          }
  65   1        else KeyTimer[0]=0; //å®šæ—¶å™¨å…³é—­
  66   1        //å®šæ—¶å™¨1ï¼ˆç”¨äºæŒ‰é”®è¿æŒ‰æ£€æµ‹ï¼‰
  67   1        if(KeyTimer[1]&0x80)
  68   1          {
  69   2          buf=KeyTimer[1]&0x7F;
  70   2          if(buf<(unsigned char)ContShortPressWindow)buf++;
  71   2          KeyTimer[1]&=0x80;
  72   2          KeyTimer[1]|=buf; //å°†æ•°å€¼å–å‡ºæ¥ï¼ŒåŠ 1å†å†™å›å»
  73   2          }
  74   1        else KeyTimer[1]=0; //å®šæ—¶å™¨å…³é—­
  75   1        }
  76          
  77          //ä¾§æŒ‰GPIOä¸­æ–­å›è°ƒå¤„ç†
  78          void SideKey_Int_Callback(void)
  79            {
  80   1        unsigned char time;
  81   1        //å¼€å§‹å“åº”
  82   1        if(GPIO_GetExtIntMode(SideKeyGPIOG,SideKeyGPIOx)==GPIO_Int_Rising)
  83   1          {
  84   2          IsKeyPressed = 0;
  85   2          time=KeyTimer[0]&0x7F;//ä»è®¡æ—¶å™¨å–å‡ºæŒ‰é”®æŒ‰ä¸‹æ—¶é—´
  86   2          KeyTimer[0]=0;//å¤ä½å¹¶å…³é—­å®šæ—¶å™¨0
  87   2          if(Keyevent.LongPressDetected||Keyevent.PressAndHoldEvent)//å¦‚æœå·²ç»æ£€æµ‹åˆ°é•¿æŒ‰äº‹ä»¶åˆ™ä¸‹é¢ä»
             -€ä¹ˆéƒ½ä¸åš
  88   2            {
  89   3            Keyevent.PressAndHoldEvent=0;
  90   3            Keyevent.LongPressDetected=0;//æ¸…é™¤æ£€æµ‹åˆ°çš„è¡¨ç¤º
  91   3            }
  92   2          else if(time<(unsigned char)LongPressTime)//çŸ­æŒ‰äº‹ä»¶å‘ç”Ÿ      
  93   2            {
  94   3            if(Keyevent.ShortPressCount<10)Keyevent.ShortPressCount++;//ç´¯åŠ æœ‰æ•ˆçš„çŸ­æŒ‰æ¬¡æ•°
  95   3            KeyTimer[1]=0x80;//å¯åŠ¨çŸ­æŒ‰å®Œæ¯•ç­‰å¾…ç»Ÿè®¡çš„è®¡æ—¶å™¨
  96   3            }     
  97   2          }
  98   1        //æŒ‰é”®æŒ‰ä¸‹
  99   1        else
 100   1          {
 101   2          IsKeyPressed = 1;//æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 102   2          SleepTimer=8*SleepTimeOut; //ç¡çœ æ—¶é—´å»¶é•¿
 103   2          if(KeyTimer[1]&0x80)KeyTimer[1]=0x80;//å¤ä½
 104   2          if(!(KeyTimer[0]&0x80))KeyTimer[0]=0x80;//å¯åŠ¨è®¡æ—¶
 105   2          }
 106   1        //ç¦æ­¢INT0ä¸­æ–­
 107   1        GPIO_DisableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ç¦æ­¢ä¸­æ–­åŠŸèƒ½
 108   1        KeyState=0x0A; //å¤ä½æ£€æµ‹æ¨¡å—
 109   1        }
 110          
 111          //æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 112          void MarkAsKeyPressed(void)
 113            {
 114   1        //ç¦æ­¢INT0ä¸­æ–­
 115   1        GPIO_DisableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ç¦æ­¢ä¸­æ–­åŠŸèƒ½
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/16/2024 15:17:13 PAGE 3   

 116   1        KeyState=0xAA; //å¤ä½æ£€æµ‹æ¨¡å—
 117   1        //æ ‡è®°æŒ‰é”®å·²è¢«æŒ‰ä¸‹
 118   1        IsKeyPressed = 1;//æ ‡è®°æŒ‰é”®æŒ‰ä¸‹
 119   1        if(KeyTimer[1]&0x80)KeyTimer[1]=0x80;//å¤ä½
 120   1        if(!(KeyTimer[0]&0x80))KeyTimer[0]=0x80;//å¯åŠ¨è®¡æ—¶
 121   1        }   
 122            
 123          //åœ¨å•å‡»åŒå‡»ä¸‰å‡»+é•¿æŒ‰è§¦å‘çš„æ—¶å€™æ¸…é™¤å•å‡»äº‹ä»¶çš„è®°å½•
 124          static void ClickAndHoldEventHandler(int PressCount)
 125            {
 126   1        KeyTimer[1]=0; //å…³é—­åéƒ¨æ£€æµ‹å®šæ—¶å™¨
 127   1        Keyevent.ShortPressEvent=0;
 128   1        Keyevent.ShortPressCount=0; //çŸ­æŒ‰æ¬¡æ•°ä¸º0
 129   1        Keyevent.LongPressDetected=0;
 130   1        Keyevent.LongPressEvent=0;//çŸ­æŒ‰å’Œé•¿æŒ‰äº‹ä»¶æ²¡å‘ç”Ÿ
 131   1        //å•å‡»+é•¿æŒ‰
 132   1        Keyevent.PressAndHoldEvent=(PressCount==1)?1:0;
 133   1        }
 134          //ä¾§æŒ‰é”®é€»è¾‘å¤„ç†å‡½æ•°
 135          void SideKey_LogicHandler(void)
 136            {   
 137   1        unsigned char buf;
 138   1        //å¯¹æŒ‰é”®è¿›è¡Œå»æŠ–ä»¥åŠé‡æ–°æ‰“å¼€ä¸­æ–­çš„åˆ¤æ–­
 139   1        if(!GPIO_CheckIfIntEnabled(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)))
 140   1          {
 141   2          KeyState<<=1;
 142   2          if(KeyPress)KeyState|=0x01;
 143   2          else KeyState&=0xFE;  //é™„åŠ ç»“æœ
 144   2          //é‡æ–°æ‰“å¼€ä¸­æ–­
 145   2          buf=KeyState&0x0F;
 146   2          if(buf==0x0F||KeyState==0x00)
 147   2            {
 148   3            P0EXTIF=0;//æ¸…é™¤GPIO Flag
 149   3            IsKeyPressed=buf==0x0F?0:1; //æ›´æ–°æŒ‰é”®çŠ¶æ€  
 150   3            GPIO_SetExtIntMode(SideKeyGPIOG,SideKeyGPIOx,buf==0x0F?GPIO_Int_Falling:GPIO_Int_Rising);//å¦‚æœå½“å‰
             -æŒ‰é”®æ˜¯æ¾å¼€çŠ¶æ€åˆ™è®¾ç½®ä¸ºä¸‹é™æ²¿ï¼Œå¦åˆ™è®¾ç½®ä¸ºä¸Šå‡æ²¿
 151   3            GPIO_EnableInt(SideKeyGPIOG,GPIOMask(SideKeyGPIOx)); //ä½¿èƒ½ä¸­æ–­åŠŸèƒ½
 152   3            }
 153   2          } 
 154   1        //å¦‚æœæŒ‰é”®é‡Šæ”¾ç­‰å¾…è®¡æ—¶å™¨åœ¨è®¡æ—¶çš„è¯ï¼Œåˆ™é‡ç½®å®šæ—¶å™¨
 155   1        if(IsKeyPressed&&(KeyTimer[1]&0x80))KeyTimer[1]=0x80;
 156   1        //é•¿æŒ‰3ç§’çš„æ—¶é—´åˆ°
 157   1        if(IsKeyPressed&&KeyTimer[0]==0x80+(unsigned char)LongPressTime)
 158   1          {
 159   2          //å¤„ç†å¤šå‡»+é•¿æŒ‰äº‹ä»¶
 160   2          if(Keyevent.ShortPressCount>0)ClickAndHoldEventHandler(Keyevent.ShortPressCount);
 161   2          else //é•¿æŒ‰äº‹ä»¶
 162   2            {
 163   3            Keyevent.ShortPressCount=0;
 164   3            Keyevent.PressAndHoldEvent=0;
 165   3            Keyevent.LongPressEvent=1;//é•¿æŒ‰äº‹ä»¶å‘ç”Ÿ
 166   3            Keyevent.LongPressDetected=1;//é•¿æŒ‰æ£€æµ‹åˆ°äº†  
 167   3            }
 168   2          KeyTimer[0]=0;//å…³é—­å®šæ—¶å™¨
 169   2          }
 170   1        //è¿ç»­çŸ­æŒ‰åºåˆ—å·²ç»ç»“æŸ
 171   1        if(!IsKeyPressed&&KeyTimer[1]==0x80+(unsigned char)ContShortPressWindow)
 172   1          {
 173   2          KeyTimer[1]=0;//å…³é—­å®šæ—¶å™¨1
 174   2          if(!Keyevent.LongPressDetected) 
 175   2            Keyevent.ShortPressEvent=1;//å¦‚æœé•¿æŒ‰äº‹ä»¶å·²ç»ç”Ÿæ•ˆï¼Œåˆ™æ¾å¼€å¼€å…³æ—¶çŸ­æŒ‰äº‹ä»¶ä¸ç”Ÿæ•ˆ
 176   2          else 
C51 COMPILER V9.60.0.0   SIDEKEY                                                           11/16/2024 15:17:13 PAGE 4   

 177   2            Keyevent.LongPressDetected=0; //æ¸…é™¤é•¿æŒ‰æ£€æµ‹åˆ°çš„ç»“æœ
 178   2          }
 179   1        }
 180          //è·å–ä¾§æŒ‰é”®ç‚¹æŒ‰æ¬¡æ•°çš„è·å–å‡½æ•°
 181          int getSideKeyShortPressCount(bit IsRemoveResult)
 182            {
 183   1        short buf;
 184   1        if(Keyevent.LongPressDetected||Keyevent.PressAndHoldEvent)return 0;
 185   1        if(!Keyevent.ShortPressEvent)return 0;
 186   1        buf=Keyevent.ShortPressCount;
 187   1        if(IsRemoveResult)
 188   1          {
 189   2          Keyevent.ShortPressEvent=0; //è·å–äº†çŸ­æŒ‰ç»“æœä¹‹åå¤ä½
 190   2          Keyevent.ShortPressCount=0;  //è·å–äº†çŸ­æŒ‰è¿å‡»æ¬¡æ•°åæ¸…é›¶ç»“æœ
 191   2          }
 192   1        return buf;   
 193   1        }
 194          //è·å–ä¾§æŒ‰æŒ‰é”®é•¿æŒ‰2ç§’äº‹ä»¶çš„å‡½æ•°
 195          bit getSideKeyLongPressEvent(void)
 196            {
 197   1        if(!Keyevent.LongPressEvent)return 0;
 198   1        else Keyevent.LongPressEvent=0;
 199   1        return 1;
 200   1        }
 201          //è·å–ä¾§æŒ‰æŒ‰é”®ä¸€ç›´æŒ‰ä¸‹çš„å‡½æ•°
 202          bit getSideKeyHoldEvent(void)
 203            {
 204   1        return Keyevent.LongPressDetected?1:0;
 205   1        }
 206          //è·å–ä¾§æŒ‰æŒ‰é”®çŸ­æŒ‰ä¸€ä¸‹ç«‹åˆ»é•¿æŒ‰çš„å‡½æ•°
 207          bit getSideKeyClickAndHoldEvent(void)
 208            {
 209   1          return Keyevent.PressAndHoldEvent?1:0;
 210   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    530    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
